\documentclass{manual}

% Links
\newcommand{\mailinglist}{\ulink{mailing list}
  {mailto:pyqwt-users@lists.sourceforge.net}}
\newcommand{\Qwt}{\ulink{Qwt}
  {http://qwt.sourceforge.net}}
\newcommand{\Grace}{\ulink{Grace}
  {http://plasma-gate.weizmann.ac.il/Grace/}}

% Source code
\newcommand{\Download}{\ulink{download}
  {http://pyqwt.sourceforge.net/download.html}}
\newcommand{\Snapshot}{\ulink{snapshot}
  {http://pyqwt.sourceforge.net/snapshot}}
\newcommand{\NewSip}{\ulink{sip-4.0.1.tar.gz}
  {http://pyqwt.sourceforge.net/support/sip-4.0.1.tar.gz}}
\newcommand{\OldSip}{\ulink{sip-3.10.2.tar.gz}
  {http://pyqwt.sourceforge.net/support/sip-3.10.2.tar.gz}}
\newcommand{\SipNcZip}{\ulink{sip-win-nc-3.8.zip}
  {http://pyqwt.sourceforge.net/support/sip-win-nc-3.8.zip}}
\newcommand{\PyQtGpl}{\ulink{PyQt-x11-gpl-3.12.tar.gz}
  {http://pyqwt.sourceforge.net/support/PyQt-x11-gpl-3.12.tar.gz}}
\newcommand{\PyQtMac}{\ulink{PyQt-mac-gpl-3.12.tar.gz}
  {http://pyqwt.sourceforge.net/support/PyQt-mac-gpl-3.12.tar.gz}}
\newcommand{\PyQtCom}{\ulink{Buy PyQt}
  {http://www.riverbankcomputing.co.uk/pyqt/buy.php}}
\newcommand{\PyQtNcZip}{\ulink{PyQt-win-nc-3.8.zip}
  {http://pyqwt.sourceforge.net/support/PyQt-win-nc-3.8.zip}}
\newcommand{\snapshot}{\ulink{snapshot}
  {http://www.river-bank.demon.co.uk/download/snapshots}}
\newcommand{\Numeric}{\ulink{Numeric}
  {http://www.numpy.org}}
\newcommand{\NumericTarGz}{\ulink{Numeric-23.1.tar.gz}
  {http://prdownloads.sourceforge.net/numpy/Numeric-23.1.tar.gz?download}}
\newcommand{\numarray}{\ulink{numarray}
  {http://www.stsci.edu/resources/software_hardware/numarray}}
\newcommand{\numarrayTarGz}{\ulink{numarray-1.0.tar.gz}
  {http://prdownloads.sourceforge.net/numpy/numarray-1.0.tar.gz?download}}
\newcommand{\PyQwtTarGz}{\ulink{PyQwt-4.0rc0.tar.gz}
  {http://prdownloads.sourceforge.net/pyqwt/PyQwt-4.0rc0.tar.gz?download}}
\newcommand{\ReadMePatches}{\ulink{README}
  {http://pyqwt.sourceforge.net/patches/README}}

% Installers for MS-Windows
\newcommand{\PythonExe}{\ulink{Python-2.3.4.exe}
  {http://www.python.org/ftp/python/2.3.4/Python-2.3.4.exe}}
\newcommand{\NumericExe}{\ulink{Numeric-23.1.win32-py2.3.exe}
  {http://prdownloads.sourceforge.net/numpy/Numeric-23.1.win32-py2.3.exe?download}}
\newcommand{\numarrayExe}{\ulink{numarray-1.0.win32-py2.3.exe}
  {http://prdownloads.sourceforge.net/numpy/numarray-1.0.win32-py2.3.exe?download}}
\newcommand{\QtNcExe}{\ulink{QtWin230-NonCommercial.exe}
  {ftp://ftp.trolltech.com/qt/non-commercial/QtWin230-NonCommercial.exe}}
\newcommand{\PyQtExe}{\ulink{PyQt-win-nc-msvc-3.12.exe}
  {http://pyqwt.sourceforge.net/support/PyQt-win-nc-msvc-3.12.exe}}
\newcommand{\PyQwtExe}{\ulink{PyQwt\_Qt230-4.0rc0.win32-py2.3.exe}
  {http://prdownloads.sourceforge.net/pyqwt/PyQwt\_Qt230-4.0rc0.win32-py2.3.exe?download}}

\newcommand{\PrerequisitesEnd}{
  To exploit the full power of the QwtPlot widget, you should install at
  least one the Numerical Python extensions:
  \Numeric{} or its successor \numarray{}.
  I am using \NumericTarGz{} and \numarrayTarGz{}. 
  Versions of Numeric later than 21.0 are supported.
  Numarray is newer and therefore less stable than Numeric, so get the latest!

  The source package \PyQwtTarGz{} contains a 20040605 CVS snapshot
  of the \Qwt{} library with a few patches.
}

\newcommand{\Future}{
  \begin{notice}[warning]
    This documentation is for the future PyQwt-4.0 which is only available from
    CVS. The \Download{} page has links for the latest releases.
  \end{notice}
}

\renewcommand{\Future}{}

\title{PyQwt Manual}

% boilerplate.tex?
\author{Gerard Vermeulen}

\date{\today}
\release{4.0}
\setshortversion{4.0}

\makeindex

\begin{document}

\maketitle

% This makes the contents more accessible from the front page of the HTML.
\ifhtml
\chapter*{Front Matter \label{front}}
\fi

\input{copyright}


\begin{abstract}

\noindent
PyQwt is a set of Python bindings for the \Qwt{} library featuring fast
plotting of Python lists and tuples and the powerful array types provided by
the Python extension modules \module{Numeric} and/or \module{numarray}.

\end{abstract}

\tableofcontents

\chapter{Introduction \label{introduction}}

PyQwt is a set of Python bindings for the \Qwt{} library featuring fast
plotting of Python lists and tuples and the powerful array types provided
by the Python extension modules \module{Numeric} and/or \module{numarray}.


 
\section{Qwt \label{qwt-intro}}

Qwt is a C++ library based on the Qt GUI framework from Troll Tech AS.
The Qwt library contains widgets and components useful to write technical
and scientific programes.
It includes the following widgets:
\begin{itemize}
  \item
    \class{QwtCompass}: a very fancy QDial-like widget to display and
    control a direction.
  \item
    \class{QwtCounter}: a QSpinBox-like widget to display and control
    a bounded floating point value.
  \item
    \class{QwtDial}: a QDial-like widget to display and control a
    floating point value.
  \item
    \class{QwtKnob}: a potentiometer-like widget to display and control
    a bounded floating point value.
  \item
    \class{QwtPlot}: a widget to plot two-dimensional data points.
  \item
    \class{QwtSlider}: a QSlider-like widget to display and control a
    bounded floating point value.
  \item
    \class{QwtThermo}: a thermometer-like widget to display a floating
    point value. 
  \item
    \class{QwtWheel}: a wheel-like widget with its axis parallel to
    the computer screen to control a floating point value over a very
    large range in very small steps.
\end{itemize}
The widgets are documented in the
\ulink{Qwt manual}{qwt/index.html}
on your hard disk or \Qwt{} on the web.

\begin{notice}[note]
  The \Qwt{} library has a designer plug-in for Qt-3.x.x.  If you want to use
  the plug-in, you must install the original \Qwt{} library or the slightly
  modified version that is included in \PyQwtTarGz{}.
\end{notice}


\section{The Python Numerical Extension modules \label{numeric-intro}}

The \Numeric{} and \numarray{} modules extend Python with multi-dimensional
array types and a complete set of 'standard' functions and operators to
manipulate the arrays.

Python together with at least one of those modules is an ideal language
experimental numerical and scientific computing (as powerful as APL, MatLab,
IDL and others, but much more elegant).

If you do not have a mathematical background, you can think of those array
types as columns in a spreadsheet.  The spreadsheet lets you do operations
on whole columns at once.  Look at the following simple example:

\verbatiminput{numeric.example}

The function call \samp{arange(0.0, 10.0, 3.0)} returns a NumPy array of 4
equidistant points from 0 to 9 inclusive: \samp{array([ 0., 3., 6., 9.])}.
The function call \samp{sin(x)} and statement \samp{x*x} show that
\samp{sin} and \samp{*} manipulate NumPy arrays element by element.
All this in C, for a manifold speedup with respect to pure Python.


\section{PyQwt \label{pyqwt-intro}}

The PyQwt widgets can be used in Graphical User Interface (GUI)
programs as well as from the Command Line Interpreter (CLI).
This section addresses:
\begin{itemize}
\item
  the CLI facilities (iqt, PyCute, qwt.qplt),
\item
  the functions to convert \class{QImage} instances to Numeric and numarray
  arrays and vice versa.
\end{itemize}

The documentation for writing GUI programs consists of the
\ulink{Qwt manual}{qwt/index.html} on your hard disk or the \Qwt{} manual on
the web, supplemented by chapter \ref{reference} to document the differences
between PyQwt and Qwt.

\subsection{iqt \label{iqt-intro}}

The programming style \emph{imposed} by PyQt (and other GUI toolkit wrappers)
is to create an application instance with some widgets and to enter into an
event loop that locks you from the Python command line interpreter.

Module \module{iqt} enables you to:
\begin{itemize}
\item
  create and control (Py)Qt widgets from the command line interpreter or an
  enhanced interpreter like \ulink{ipython}{http://ipython.scipy.org}.
\item
  to interact with those widgets through (Py)Qt's GUI.
\end{itemize}

Module \module{iqt} works by hooking \cfunction{qApp->processEvents()} on the
event hook of the readline module.
The GNU readline library closes the event loop by calling 
\cfunction{qApp->processEvent()} at a maximum rate of 10 times per second
while reading your keyboard input.

To see how \module{iqt} works, play with \file{ICompass.py} by running
\begin{verbatim}
python -i ICompass.py
\end{verbatim}
or
\begin{verbatim}
python ICompass.py
\end{verbatim}
or
\begin{verbatim}
ipython ICompass.py
\end{verbatim}


\begin{notice}[warning]
  The module \module{iqt} will not work with a MSVC-compiled Python, because
  it has no \module{readline} module.
\end{notice}


\subsection{PyCute \label{pycute-intro}}

\program{PyCute} embeds a Python shell in a \class{QMultiLineEdit} widget
(Qt-2.x) or a \class{QTextEdit} widget (Qt-3.x) that works nicely with
\module{qwt.qplt}, see \ref{qwt-qplt}.

Possible invokations of the \program{PyCute} are:
\begin{verbatim}
PyCute --demo
\end{verbatim}
or:
\begin{verbatim}
PyCute
\end{verbatim}
or from the examples directory:
\begin{verbatim}
PyCute ICompass.py
\end{verbatim}

The first command creates a PyCute shell and executes eight Python statements
to create a \class{Plot} and an \class{IPlot} widget.

Both widgets allow you to select a new zoom region by pressing the left button,
dragging the mouse and releasing the left button.
The previous zoom region is placed on an infinite stack, so that you can
unzoom to previous zoom regions by clicking the right button.

Both widgets allow you to hide/unhide curves by clicking on a legend item.

In addition, the \class{IPlot} widgets displays the plot coordinates in the
status bar and has a toolbar buttons to print and to clone the plot into
\Grace{}.
\Grace{} is a WYSIWYG plot program that produces output very well adapted to
scientific journals.

The second command gives you a plain PyCute shell and the third command 
interpretes the ICompass.py program.

Type \kbd{Control-D} to exit the shell.
 

\subsection{qwt.qplt \label{qwt-qplt}}

The module \module{qwt.qplt} defines a tiny data-directed programming
language to simplify the use of \class{QwtPlot} from the Python command
line interpreter or from an embedded Python shell like in \program{PyCute}.
Here follows a small example:

\verbatiminput{qplt.example}

\subsubsection{qwt.qplt.Plot \label{intro-qplt-plot}}

\begin{classdesc}{Plot}{*arguments}
  \class{Plot} takes any number of optional arguments.
  The data-directed interpretation of each optional argument is:
  \begin{itemize}
  \item
    \class{Axis}, to enable and redefine an axis.
  \item
    \class{Curve}, to add a curve to the plot.
  \item
    \class{QString} or a \class{string}, to set the title of the plot.
  \item
    \class{int}, to attach a set of mouse events to the zoomer actions.
  \item
    (\class{int}, \class{int}), to set the size of the plot.
  \end{itemize}

  \class{Plot} has an infinite deep stack of zoom regions. You can:
  \begin{itemize}
    \item
      select a zoom region
    \item
      unzoom all
    \item
      walk down the stack
    \item
      walk up the stack.
  \end{itemize}

  \class{Plot} uses \method{__getattr__()} to inherit all methods of
  \class{QwtPlot}.
\end{classdesc}

In addition, the class \class{Plot} defines the following methods:

\begin{methoddesc}[Plot]{clearZoomStack}{self}
Force autoscaling and clear the zoom stack.
\end{methoddesc}

\begin{methoddesc}[Plot]{formatCoordinates}{self, x, y}
Format mouse coordinates as real world plot coordinates.
\end{methoddesc}

\begin{methoddesc}[Plot]{getZoomerMouseEventSet}{self}
Return the index of the set of mouse events attached to the QwtPlotZoomer
actions.
\end{methoddesc}

\begin{methoddesc}[Plot]{gracePlot}{self}
Clone the plot into \Grace{} for very high quality hard copy output.
\end{methoddesc}

\begin{methoddesc}[Plot]{plot}{self, *curves}
Plot a list of curves.
\end{methoddesc}

\begin{methoddesc}[Plot]{plotAxis}{self, orientation, options, title}
Plot and enables an axis.
\end{methoddesc}

\begin{methoddesc}[Plot]{plotCurve}{self, curve}
Plot a single curve.
\end{methoddesc}

\begin{methoddesc}[Plot]{setZoomerMouseEventSet}{self, index}
Attach the QwtPlotZoomer actions to set of mouse events.
\end{methoddesc}

\begin{methoddesc}[Plot]{toggleCurve}{self, key}
Toggle a curve between hidden and shown.
\end{methoddesc}

\subsubsection{qwt.qplt.IPlot \label{intro-qplt-iplot}}

\begin{classdesc}{IPlot}{*arguments}
  \class{IPlot} is a main window with a Plot widget as central widget.

  The data-directed interpretation of each optional argument is the
  same as for \class{Plot}:
  \begin{itemize}
  \item
    \class{Axis}, to enable and redefine an axis.
  \item
    \class{Curve}, to add a curve to the plot.
  \item
    \class{QString} or a \class{string}, to set the title of the plot.
  \item
    \class{int}, to attach a set of mouse events to the zoomer actions.
  \item
    (\class{int}, \class{int}), to set the size of the plot.
  \end{itemize}

  The functionality of \class{Plot} is enhanced with a tool bar with
  buttons for printing and cloning into \Grace{} and a combo box to attach
  the zoomer actions to a set of mouse events.
  In addition, the position of the cursor in the plot region is tracked
  and displayed in a status bar. 

  \class{IPlot} uses \method{__getattr__()} to inherit all methods of
  \class{QMainWindow} and \class{IPlot}.


In addition, the class \class{IPlot} defines the following methods:

\begin{methoddesc}[Plot]{onMouseMoved}{self, event}
Translate the mouse coordinates to plot coordinates for display in the status
bar.
\end{methoddesc}

\begin{methoddesc}[IPlot]{printPlot}{self}
Initialize a high resolution printer (if possible) for color output to file and
print the plot.
\end{methoddesc}

\end{classdesc}

\subsubsection{qwt.qplt.Curve \label{intro-qplt-curve}}

\begin{classdesc}{Curve}{x, y, *arguments}
  \class{Curve} takes two obligatory arguments followed by any number of
  optional arguments. The arguments \var{x} and \var{y} must be sequences
  of \class{float} objects.
  The data-directed interpretation of each optional argument is:
  \begin{itemize}
  \item
    \class{Axis}, to attach an axis to the curve.
  \item
    \class{Pen}, to select a pen to connect the data points.
  \item
    \class{Symbol}, to select a symbol to the data points.
  \item
    \class{string} or \class{QString}, to set the title of the curve.
  \end{itemize}
\end{classdesc}

\subsubsection{qwt.qplt.Axis \label{intro-qplt-axis}}

\begin{classdesc}{Axis}{*arguments}
  \class{Axis} takes any number of optional arguments.
  The data-directed interpretation of each optional argument is:
  \begin{itemize}
  \item
    \class{AxisOrientation}, to set the orientation of the axis.  Predefined
    instances of \class{AxisOrientation} are \constant{Left}, \constant{Right},
    \constant{Bottom} and \constant{Top}.
  \item
    \class{int}, to set the options of the axis.
  \item
    \class{string} or \class{QString}, to set the title of the axis.
  \end{itemize}
\end{classdesc}

\subsubsection{qwt.qplt.Pen \label{intro-qplt-pen}}

\begin{classdesc}{Pen}{*arguments}
  \class{Pen} takes any number of optional arguments.
  The data-directed interpretation of each optional argument is:
  \begin{itemize}
  \item
    \class{PenStyle}, to set the style of the pen.
  \item
    \class{QColor}, to set the color of the pen.
  \item
    \class{int}, to set the width of the pen.
  \end{itemize}
\end{classdesc}

\subsubsection{qwt.qplt.Symbol \label{intro-qplt-symbol}}

\begin{classdesc}{Symbol}{*arguments}
  \class{Symbol} takes any number of optional arguments.
  The data-directed interpretation of each optional argument is:
  \begin{itemize}
  \item
    \class{QColor}, to set the fill color of the symbol.
  \item
    \class{SymbolStyle}, to set the style of the symbol. Predefined instances
    of \class{SymbolStyle} are \constant{NoSymbol}, \constant{Circle},
    \constant{Square} and \constant{Diamond}.
  \item
    \class{int}, to set the size of the symbol.
  \end{itemize}
\end{classdesc}

\subsection{QImage and Numeric/numarray arrays \label{qwt-qimage}}

\begin{funcdesc}{toImage}{array}
  Convert \var{array} to a QImage, where \var{array} must be a two-dimensional
  Numeric array of type UnsignedInt8, UnsignedInt16 or UnsignedInt32 or a
  two-dimensional numarray array of type UInt8, UInt16 or UInt32.
\end{funcdesc}

\begin{funcdesc}{to_na_array}{image}
  Convert \var{image} of type \class{QImage} to a numarray array. This function
  is only present if numarray has been detected when building PyQwt.
\end{funcdesc}

\begin{funcdesc}{to_np_array}{image}
  Convert \var{image} of type \class{QImage} to a Numeric array. This function
  is only present if Numeric has been detected when building PyQwt.
\end{funcdesc}

\begin{notice}[warning]
Those functions ignore endianness and are untested on 64-bit platforms.
Feedback, please.
\end{notice}


\chapter{Installation \label{installation}}

\Future{}

You can install PyQwt on the \POSIX{} (Unix, Linux), MacOS/X,
and Microsoft Windows operating systems:
\begin{enumerate}
  \item
    see \ref{prerequisites} for the software packages needed to build 
    and install PyQwt.
  \item
    see \ref{build-configure} for build and installation instructions
    using \file{configure.py}.
    Recommended unless you want to make an installer (.rpm on some
    Linux systems and .exe on Microsoft Windows).
  \item
    see \ref{build-setup} for build and installation instructions
    using \file{setup.py}.
    Only recommended if you want to make an installer (.rpm on some
    Linux systems and .exe on Microsoft Windows).
  \item
    see \ref{win-binary-install} for instructions on the use of the binary
    Windows installer, to be used with the non-commercial packages
    \QtNcExe{} and \PyQtExe{}.
\end{enumerate}

Contact the \mailinglist{}, if you run into problems.

\begin{notice}[note]
  The compatibility of PyQwt's build scripts with the commercial packages of Qt
  and PyQt on Windows depends on \strong{your} feedback, because I do not have
  access to those versions of Qt and PyQt.
\end{notice}

\section{Build prerequisites \label{prerequisites}}

\subsection{Build prerequisites for PyQwt on \POSIX{}}

\Future{}

Build prerequisites for \PyQwtTarGz{} on \POSIX{} are:
\begin{enumerate}
  \item
    \ulink{Python}{http://www.python.org}.\\
    Supported versions: Python-2.4.x, Python-2.3.x, Python-2.2.x, and probably
    also Python-2.1.x.
  \item
    \ulink{Qt}{http://www.trolltech.com}.\\
    Supported versions: Qt-3.3.x, Qt-3.2.x, Qt-3.1.x, Qt-3.0.x,
    Qt-2.3.1 and Qt-2.3.0.
  \item
    \NewSip{} (requires at least Python-2.3.0) or \OldSip{}.\\
    Supported versions: sip-4.0.1, -4.0, -3.10.2, -3.10.1, and -3.10,
    but the most recent version gets most testing.
    You may also try a \snapshot{} at your own risk.
  \item
    \PyQtGpl{}.\\
    Supported versions: PyQt-3.12, -3.11, and -3.10,
    but the most recent version gets most testing.
    You may also try a \snapshot{} at your own risk.
  \item
    \ReadMePatches{} for bug fixes and upgrades.
\end{enumerate}

\begin{notice}[note]
  You must install sip and PyQt with the 'configure.py' script instead
  of the deprecated 'build.py' script.
\end{notice}

\PrerequisitesEnd{}

\subsection{Build prerequisites for PyQwt on MacOS/X}

\Future{}

Build prerequisites for \PyQwtTarGz{} on MacOS/X are:
\begin{enumerate}
  \item
    \ulink{Python}{http://www.python.org}.\\
    Supported versions: Python-2.4.x and Python-2.3.x.
  \item
    \ulink{Qt}{http://www.trolltech.com}.\\
    Supported versions: Qt-3.3.x, Qt-3.2.x, Qt-3.1.x, and Qt-3.0.x.
  \item
    \NewSip{}.\\
    Supported versions: sip-4.0.1, and -4.0.
    You may also try a \snapshot{} at your own risk.
  \item
    \PyQtMac{}.\\
    Supported versions: PyQt-3.12, -3.11, and -3.10, but the most recent
    version gets most testing.
    You may also try a \snapshot{} at your own risk.
  \item
    \ReadMePatches{} for bug fixes and upgrades.
\end{enumerate}

\begin{notice}[note]
  You must install sip and PyQt with the 'configure.py' script instead of the
  deprecated 'build.py' script.
\end{notice}

\PrerequisitesEnd{}


\subsection{Build prerequisites for PyQwt on Windows}

\Future{}

Build prerequisites for \PyQwtTarGz{} on Windows are:
\begin{enumerate}
  \item
    \PythonExe{}.\\
    Supported versions: Python-2.4.x, Python-2.3.x, Python-2.2.x, and probably
    also Python-2.1.x.
  \item
    \ulink{Qt}{http://www.trolltech.com}.\\
    Supported versions: Qt-3.3.x, Qt-3.2.x, Qt-3.1.x, Qt-3.0.x,
    Qt-2.3.1 and Qt-2.3.0.
  \item
    \NewSip{} (requires at least Python-2.3.0) or \OldSip{}.\\
    Supported versions: sip-4.0.1, -4.0, -3.10.2, -3.10.1, and -3.10,
    but the most recent version gets most testing.
    You may also try a \snapshot{} at your own risk.
  \item
    \PyQtCom{}.\\
    Supported versions: PyQt-3.12, -3.11, and -3.10, but the most recent
    version gets most testing.
    You may also try a \snapshot{} at your own risk.
  \item
    \ReadMePatches{} for bug fixes and upgrades.
\end{enumerate}

\begin{notice}[note]
  You must install sip and PyQt with the 'configure.py' script instead of the
  deprecated 'build.py' script.
\end{notice}

\PrerequisitesEnd{}

\begin{notice}[warning]
  Most installation problems are related to the presence of
  old executables (\file{sip.exe}),
  old libraries (\file{libqt*.exp}, \file{libqt*.lib}, \file{lib.qt*.pyd},
  \file{libsip.exp}, \file{libsip.lib}, \file{libsip.pyd}),
  old header files (\file{sip.h}, \file{sipQt.h})
  or old Python files (\file{qt*.py}, \file{qt*.pyc}).
\end{notice}


\section{Build with \file{configure.py}\label{build-configure}}

\Future{}

\begin{enumerate}
\item
  Unpack \PyQwtTarGz{} and read this \ReadMePatches{} to check for patches.
\item
  Configure PyQt by running the following commands:
\begin{verbatim}
cd PyQwt-4.0
cd configure
python configure.py
\end{verbatim}
  This assumes that the correct Python interpreter is on your path.
  The configure.py script takes many options.
  Use the "-h" command line option to display a full list of the available
  options.
\item
  The next step is to build PyQt using your platform's make command.
\begin{verbatim}
make
\end{verbatim}
\item
  The final step is to install PyQt by running the following command.
\begin{verbatim}
make install
\end{verbatim}
\end{enumerate}

\begin{notice}[warning]
  If the make command produces a lot of errors on Linux, check if all
  development packages have been installed.  Try the \file{setup.py}
  script in \ref{build-setup}, because does a better job of detecting
  missing files than \file{configure.py}. 
\end{notice}

\begin{notice}[note]
  The official PyQwt-4.0 release will allow you to build and link
  PyQwt using system a Qwt-4.2.0 library (does not work with PyQwt and
  Qwt release candidates). Run for instance
\begin{verbatim}
python configure.py -c -j 2 -i /usr/lib/qt3/include/qwt -l /usr/lib/qt3/lib
\end{verbatim}
  to use the Qwt include files in \file{/usr/lib/qt3/include/qwt} and
  the Qwt library in \file{/usr/lib/qt3/lib}.
\end{notice}


\section{Build with \file{setup.py}\label{build-setup}}

\subsection{Build on \POSIX{} with \file{setup.py}\label{posix-setup}}

\Future{}

\begin{enumerate}
\item
  Unpack \PyQwtTarGz{} and read \ReadMePatches{} to check for minor bug fixes
  and upgrades.
\item
\begin{verbatim}
cd PyQwt-4.0
\end{verbatim}
  {}
\item
  Edit the file \file{setup_cfg_posix} as explained in its comments.
  \verbatiminput{setup_cfg_posix}
\item
  The environment variable \envvar{QTDIR} must be set to the Qt directory
  containing the sub-directories \file{bin}, \file{lib} and \file{include}.
  You may even try to install PyQwt on Qt installations with a non-standard
  directory layout, if you set either \envvar{QTBINDIR} and/or
  \envvar{QTINCDIR} and/or \envvar{QTLIBDIR}.
\item
  If you use Qt-2.3.x, the environment variable \envvar{TMAKEPATH} must be set
  to the directory containing the file \file{tmake.conf} for your compiler.
  If you use Qt-3.x, you may have to set the environment variable
  \envvar{QMAKESPEC}.
\item
  Run
\begin{verbatim}
python setup.py build
\end{verbatim}
  to build the PyQwt extension.
\item
  Play with the \file{*.py} files in the examples directory.
  If everything works, you are ready to install.
\item
  After the removal of \emph{all} files of previous installations of PyQwt
  in your Python library tree, you have the choice between installing:
\begin{verbatim}
python setup.py install
\end{verbatim}
  or anticipating future removal of your new PyQwt installation:
  \begin{itemize}
  \item
    in case of a RPM based distribution, running
\begin{verbatim}
python setup.py bdist_rpm
\end{verbatim}
    makes RPM packages in the sub-directory \file{dist}.
    Uninstall an obsolete RPM package of PyQwt by running
\begin{verbatim}
rpm -e PyQwt
\end{verbatim}
    before installing a new RPM package with a command like
\begin{verbatim}
rpm -Uvh dist/PyQwt*.i586.rpm
\end{verbatim}
    {}
  \item
    in other cases, running
\begin{verbatim}
python setup.py bdist_dumb
\end{verbatim}
    makes a "dumb" distribution: an archive to be unpacked under /.
    If you keep the archive, you you have a trace of the installed files.
    Debian users may be able to convert the archive to a Debian package
    with \program{alien}.
  \end{itemize}
\end{enumerate}

\begin{notice}[note]
  The PyQtDistutils scripts will guide you in setting the environment variable
  \envvar{QTDIR} (and \envvar{TMAKEPATH} or \envvar{QMAKESPEC}, if required).
\end{notice}

\begin{notice}[note]
  If you are desperate, run:
\begin{verbatim}
make force
\end{verbatim}
  and mail the file \file{LOG.force} to the \mailinglist{}.
\end{notice}

\begin{notice}[note]
  Look at the Makefile for examples how to use
\begin{verbatim}
python setup.py command --options
\end{verbatim}
  For example, the command:
\begin{verbatim}
python setup.py run_sip --sip-file-dirs=../PyQt-x11-gpl-3.9/sip build
\end{verbatim}
  tries to build the extension, overruling any initialization of
  \var{sip_file_dirs} in the configuration file.
\end{notice}


\subsection{Build on Windows with \file{setup.py} \label{win-setup}}

\Future{}

\begin{enumerate}
\item
  Unpack \PyQwtTarGz{} and read \ReadMePatches{} to check out bug fixes and
  upgrades.
\item
  Run
  \begin{verbatim}
cd PyQwt-4.0
  \end{verbatim}
  {}
\item
  The commands
  \begin{verbatim}
python setup.py bdist
  \end{verbatim}
  or
  \begin{verbatim}
python setup.py bdist_wininst
  \end{verbatim}
  will make an installer in the sub-directory \file{dist}.
\end{enumerate}

\begin{notice}[note]
  The Distutils of Python-2.3.x refuse to compile extension modules with
  MSCV-7.0 when Python has been compiled with MSVC-6.0.
  If you do not want to recompile Python, edit get_build_version() in
  \file{distutils/msvccompiler.py} so that it returns a version matching
  MSVC.
\end{notice}

\begin{notice}[note]
  The PyQtDistutils rely on the environment variables \envvar{QTDIR},
  \envvar{TMAKEPATH} for Qt-2.x and \envvar{QMAKESPEC} for Qt-3.x.
\end{notice}

\begin{notice}[note]
  If you are desperate, run:
  \begin{verbatim}
python setup.py build --force >log.txt
  \end{verbatim}
  and mail the file \file{log.txt} to the \mailinglist{}.
\end{notice}


\section{Binary Installation on Windows \label{win-binary-install}}

\Future{}

\begin{notice}[warning]
Use any version of Windows later than Windows-98.  Windows-98 can only
allocate a finite number of pixmaps and \QtNcExe{} fails to work
around this limitation.  If you must stick to Windows-98, try also
PyQwt-3.8 from the \Download{} page.
\end{notice}

First, you have to install Python, Numeric, Qt-Non-Commercial and
PyQt-Non-Commercial by executing the following installation programs:
\begin{enumerate}
  \item
    \PythonExe{}
  \item
    \NumericExe{}
  \item
    \QtNcExe{}
  \item
    \PyQtExe{}
\end{enumerate}
Then, run \PyQwtExe{} and you are set.
Example programs and documentation for PyQwt and \Qwt{} are installed
in the folder \file{C:/Python23/PyQwt}.


\chapter{PyQwt Module Reference \label{reference}}

The reference should be used in conjunction with the
\ulink{Qwt manual}{qwt/index.html} on your hard disk or \Qwt{} on the web.
Only the differences specific to the Python bindings are documented here.

In this chapter, \emph{is not yet implemented} implies that the feature can
be easily implemented if needed, \emph{is not implemented} implies that the
feature is not easily implemented, and \emph{is not Pythonic} implies that
the feature will not be implemented because it violates the Python philosophy
(e.g. may use dangling pointers).

If a class is described as being \emph{fully implemented} then all non-private
member functions and all public class variables have been implemented.

Undocumented classes have not yet been implemented or are still experimental.

The classes in the Qwt library have quite a few protected attributes.
They are not yet available in Python (as far as I know, sip wraps
protected member function, but not protected attributes).
I may try to implement protected attributes on demand.

\begin{classdesc}{Qwt}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtAnalogClock}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtArrowButton}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtAutoScale}{*args}

  \begin{itemize}
  
    \item{adjust}. C++ declaration:
      \begin{verbatim}
void adjust(double minVal, double maxVal, int reset = 0);
void adjust(double* x, int size, int reset = 0);
      \end{verbatim}
      Python usage:
      \begin{verbatim}
autoScale.adjust(minVal, maxVal, reset = 0)
autoScale.adjust(x, reset = 0)
    \end{verbatim}
      The first form takes two floats and a boolean.
      The second form takes a list, tuple or NumPy array of floats and a
      boolean.

  \end{itemize}
\end{classdesc}

\begin{classdesc}{QwtCompass}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtCompassMagnetNeedle}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtCompassRose}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtCompassWindArrow}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtCounter}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtCurve}{*args}

  \begin{itemize}

    \item{setData}. C++ declaration:
      \begin{verbatim}
void setData(double* x, double* y, int size)
      \end{verbatim}
      Python usage:
      \begin{verbatim}
curve.setData(x, y)
      \end{verbatim}
      \var{x} and \var{y} can be any combination of lists, tuples and Numeric
      arrays of floats.
      All sequences are internally truncated to the length of the shortest
      sequence.

    \item{setRawData}. C++ declaration:
      \begin{verbatim}
      void setRawData(double* x, double* y, int size)
      \end{verbatim}
      \code{setRawData} \emph{is not Pythonic}.

    \item{verifyRange}. C++ declaration:
      \begin{verbatim}
      int verifyRange(int& i1, int& i2);
      \end{verbatim}
      Python usage:
      \begin{verbatim}
      length, first, last = curve.verifyRange(i1, i2)
      \end{verbatim}

  \end{itemize}
\end{classdesc}

\begin{classdesc}{QwtCurveDict}{*args}
\emph{FIXME}.
\end{classdesc}

\begin{classdesc}{QwtData}{*args}
\emph{is not implemented, because of the virtual copy destructor}.
\end{classdesc}

\begin{classdesc}{QwtDblRange}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtDiMap}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtDial}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtDialNeedle}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtDialScaleDraw}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtDialSimpleNeedle}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtDoublePoint}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtDoublePointData}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtDoubleRect}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtDoubleSize}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtDynGridLayout}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtEventPattern}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtGrid}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtKnob}{*args}
\emph{is fully implemented}. See QwtSliderBase.
\end{classdesc}

\begin{classdesc}{QwtLayoutMetrics}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtLegend}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtLegendButton}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtLegendItem}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtLegendLabel}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtMarker}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtPlotPicker}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtMarkerDict}{*args}
\emph{FIXME}.
\end{classdesc}

\begin{classdesc}{QwtMetricsMap}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtPaintBuffer}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtPainter}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtPicker}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtPickerClickPointMachine}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtPickerClickRectMachine}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtPickerDragPointMachine}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtPickerDragRectMachine}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtPickerPolygonMachine}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtPlainText}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtPlot}{*args}

  \begin{itemize}

    \item{print}. C++ declaration:
      \begin{verbatim}
void print(QPrinter &, const QwtPlotPrintFilter &);
void print(QPainter *, const QRect &, const QwtPlotPrintFilter &);
      \end{verbatim}
      \code{print} has been renamed to \code{printPlot} in Python.

    \item{curveKeys}. C++ declaration:
      \begin{verbatim}
QArray<long> curveKeys() const;
      \end{verbatim}
      \code{curveKeys} returns a list containing the keys of all curves.

    \item{closestCurve}. C++ declaration:
      \begin{verbatim}
long closestCurve(int xPos, int yPos, int& distance) const;
long closestCurve(int xPos, int yPos, int& distance,
                  double& xVal, double& yVal, int& index) const;
      \end{verbatim}
      Python usage:
      \begin{verbatim}
key, distance, xVal, yVal, index = plot.closestCurve(xPos, yPos)
      \end{verbatim}

    \item{setCurveData}. C++ declaration:
      \begin{verbatim}
bool setCurveData(long key, double *x, double *y, int size);
      \end{verbatim}
      Python usage:
      \begin{verbatim}
plot.setCurveData(key, x, y)
      \end{verbatim}
      \code{key} is an index to the curve and \code{x} and \code{y} are any
      combination of lists, tuples or NumPy arrays of Python floats.
      All sequences are internally truncated to the length of the shortest
      sequence.

    \item{setCurveRawData}. C++ declaration:
      \begin{verbatim}
bool setCurveRawData(long key, double* x, double* y, int size);
      \end{verbatim}
      \code{setCurveRawData} is not Pythonic.

    \item{axisMargins}. C++ declaration:
      \begin{verbatim}
bool axisMargins(int axis, double& lowMargin, double& highMargin) const;
      \end{verbatim}
      Python usage:
      \begin{verbatim}
valid, lowMargin, highMargin = plot.axisMargins(axis)
      \end{verbatim}
      If the axis is valid, valid=1. If the axis is invalid, valid=0.

    \item{axisLabelFormat}. C++ declaration:
      \begin{verbatim}
void axisLabelFormat(int axis, char& format, int& precision, int& width) const;
      \end{verbatim}
      Python usage:
      \begin{verbatim}
format, precision, width = plot.axisLabelFormat(axis)
      \end{verbatim}

    \item{closestMarker}. C++ declaration:
      \begin{verbatim}
long closestMarker(int xPos, int yPos, int& distance) const;
      \end{verbatim}
      Python usage:
      \begin{verbatim}
key, distance = plot.closestMarker(xPos, yPos)
      \end{verbatim}
      \code{closestMarker} takes the x- and y-coordinates of a point and
      returns a tuple containing the key of the closest marker and the distance
      between the closest marker and the point.

    \item{markerKeys}. C++ declaration:
      \begin{verbatim}
QArray<long> markerKeys() const;
      \end{verbatim}
      \code{markerKeys} returns a list containing the keys of all markers.

    \item{markerPos}. C++ declaration:
      \begin{verbatim}
void markerPos(long key, double& x, double& y) const;
      \end{verbatim}
      Python usage:
      \begin{verbatim}
x, y = plot.markerPos(key)
      \end{verbatim}
      \code{markerPos} takes the key of a marker and returns a tuple containing
      the x- and y-coordinates.

  \end{itemize}
\end{classdesc}

\begin{classdesc}{QwtPlotCanvas}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtPlotCurve}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtPlotGrid}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtPlotItem}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtPlotLayout}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtPlotMappedItem}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtPlotMarker}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtPlotPrintFilter}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtPlotZoomer}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtPushButton}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtRect}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtRichText}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtScale}{*args}

  \begin{itemize}

    \item{labelFormat}. C++ declaration:
      \begin{verbatim}
void labelFormat(char& format, int& precision, int& width) const;
      \end{verbatim}
      Python usage:
      \begin{verbatim}
format, precision, width = scale.labelFormat()
      \end{verbatim}

    \item{minBorderDist}. C++ declaration:
      \begin{verbatim}
void minBorderDist(int& start, int& end) const;
      \end{verbatim}
      Python usage:
      \begin{verbatim}
start, end = scale.minBorderDist()
      \end{verbatim}

  \end{itemize}
\end{classdesc}

\begin{classdesc}{QwtScaleDiv}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtScaleDraw}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtScaleIf}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtSimpleCompassRose}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtSlider}{*args}
\emph{is fully implemented}. See QwtSliderBase.
\end{classdesc}

\begin{classdesc}{QwtSliderBase}{*args}
\emph{is fully implemented}.

  \begin{itemize}

    \item{getScrollMode}. C++ declaration:
      \begin{verbatim}
virtual void getScrollMode(const QPoint& point, int& mode, int& direction) = 0;
      \end{verbatim}
      Python usage:
      \begin{verbatim}
mode, direction = sliderBase.getScrollMode(point)
      \end{verbatim}
      See QwtKnob, QwtSlider and QwtWheel.

  \end{itemize}
\end{classdesc}

\begin{classdesc}{QwtSpline}{*args}
  
  \begin{itemize}

    \item{recalc}. C++ declaration:
      \begin{verbatim}
int recalc(double* x, double* y, int n, bool periodic = 0);
      \end{verbatim}
      Python usage:
      \begin{verbatim}
errorCode = spline.recalc(x, y, periodic)
      \end{verbatim}
      \var{x} and \var{y} are a sequence of floats and \var{periodic} is a
      boolean.
      The sequences can be a list, a tuple or a NumPy array and all sequences
      are internally truncated to the length of the shortest sequence.

    \item{copyValues}. C++ declaration:
      \begin{verbatim}
void copyValues(int enable = 1);
      \end{verbatim}
      copyValues is not Pythonic.

  \end{itemize}
\end{classdesc}
 
\begin{classdesc}{QwtSymbol}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtText}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtThermo}{*args}
\emph{is fully implemented}.
\end{classdesc}

\begin{classdesc}{QwtWheel}{*args}
\emph{is fully implemented}. See QwtSliderBase.
\end{classdesc}

%begin{latexonly}
\renewcommand{\indexname}{Index}
%end{latexonly}
\input{\jobname.ind}

\end{document}

%% Local Variables:
%% fill-column: 79
%% End: