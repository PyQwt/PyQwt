""" pyqt_distutils.pyqwt_sip_output_patch

Patches the *.cpp, *.h and *.py files produced by sip.
"""
#
# Copyright (C) 2003 Gerard Vermeulen
#
# This file is part of PyQwt
#
# PyQwt is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# PyQwt is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU  General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# PyQwt; if not, write to the Free Software Foundation, Inc., 59 Temple Place,
# Suite 330, Boston, MA 02111-1307, USA.
#
# In addition, as a special exception, Gerard Vermeulen gives permission to
# link PyQwt dynamically with commercial, non-commercial or educational
# versions of Qt, PyQt and sip, and distribute PyQwt in this form, provided
# that equally powerful versions of Qt, PyQt and sip have been released under
# the terms of the GNU General Public License.
#
# If PyQwt is dynamically linked with commercial, non-commercial or educational
# versions of Qt, PyQt and sip, PyQwt becomes a free plug-in for a non-free
# program.


import os
import re

def pyqwt_sip_output_patch(directory, name):
    """Patch the output of the code generated by sip.
    """
    print '... patching the code generated by sip'
    
    cpp_module = os.path.join(directory, '%scmodule.cpp' % name)
    print '... adding "import_array();" to %s' % cpp_module 
    file = open(cpp_module, 'r')
    text = file.read()
    file.close()
    text = text.replace('\tPy_InitModule("lib%sc",methods);'
                        % name,
                        '\tPy_InitModule("lib%sc",methods);'
                        '\n#ifdef HAS_NUMERIC'
                        '\n\timport_NumericArray();'
                        '\n#endif'
                        '\n#ifdef HAS_NUMARRAY'
                        '\n\timport_NumarrayArray();'
                        '\n#endif'
                        % name)
    backup(cpp_module, '.numpy')
    file = open(cpp_module, 'w')
    file.write(text)
    file.close()

    py_wrapper = os.path.join(directory, '%s.py' % name)
    print '... adding the keyword arguments to the Python constructors'
    file = open(py_wrapper, 'r')
    text = file.read()
    file.close()
    text = keywords('lib%sc' % name, text)
    backup(py_wrapper, '.keywords')
    file = open(py_wrapper, 'w')
    file.write(text)
    file.close()

# pyqwt_sip_output_patch()


def replacer(matchObj):
    if matchObj.group(2) == '*args':
        return (
            "%(head)s\n"
            "%(tabs)s\tfor key in kwargs.keys():\n"
            "%(tabs)s\t\tmethod = getattr(self, key)\n" 
            "%(tabs)s\t\tif type(kwargs[key]) == type(()):\n" 
            "%(tabs)s\t\t\tapply(method,kwargs[key])\n"
            "%(tabs)s\t\telse:\n"
            "%(tabs)s\t\t\tmethod(kwargs[key])\n" %
            { 'head' : re.sub('\*args', '*args,**kwargs', matchObj.group(0)),
              'tabs' : matchObj.group(1) } )

# replacer()

def keywords(module, text):
    initRE = re.compile(r'(\t+)def __init__\(self,(\*args)\):\n'
                        '(\t+)%s\.sipCallCtor\(\d+,self,args\)' % module)
    return re.sub(initRE, replacer, text)

# keywords()

# Windows and Unix behave differently: Unix does not need os.remove()
def backup(source, extension):
    target = source + extension
    if os.path.exists(target):
        os.remove(target)
    os.rename(source, target)

# backup()

# Local Variables: ***
# compile-command: "python setup.py build" ***
# End: ***
